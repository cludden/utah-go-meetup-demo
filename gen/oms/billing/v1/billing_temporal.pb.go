// Code generated by protoc-gen-go_temporal. DO NOT EDIT.
// versions:
//
//	protoc-gen-go_temporal 1.14.3 (d2f9bfc0a16171313109a7b80bc10fabc41196e0)
//	go go1.21.12
//	protoc (unknown)
//
// source: oms/billing/v1/billing.proto
package billingv1

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	expression "github.com/cludden/protoc-gen-go-temporal/pkg/expression"
	helpers "github.com/cludden/protoc-gen-go-temporal/pkg/helpers"
	scheme "github.com/cludden/protoc-gen-go-temporal/pkg/scheme"
	gohomedir "github.com/mitchellh/go-homedir"
	v2 "github.com/urfave/cli/v2"
	enumsv1 "go.temporal.io/api/enums/v1"
	activity "go.temporal.io/sdk/activity"
	client "go.temporal.io/sdk/client"
	temporal "go.temporal.io/sdk/temporal"
	testsuite "go.temporal.io/sdk/testsuite"
	worker "go.temporal.io/sdk/worker"
	workflow "go.temporal.io/sdk/workflow"
	protojson "google.golang.org/protobuf/encoding/protojson"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	"log/slog"
	"os"
	"sort"
	"time"
)

// WorkerTaskQueue is the default task-queue for a oms.billing.v1.Worker worker
const WorkerTaskQueue = "billing-v1"

// oms.billing.v1.Worker workflow names
const (
	ChargeWorkflowName = "billing.v1.Charge"
)

// oms.billing.v1.Worker workflow id expressions
var (
	ChargeIdexpression = expression.MustParseExpression("Charge:${! idempotencyKey.or(uuid_v4()) }")
)

// oms.billing.v1.Worker workflow search attribute mappings
var (
	ChargeSearchAttributesMapping = expression.MustParseMapping("CustomerId = customerId \nFulfillmentId = fulfillmentId \nOrderId = orderId \n")
)

// oms.billing.v1.Worker activity names
const (
	CheckFraudActivityName      = "oms.billing.v1.Worker.CheckFraud"
	GenerateInvoiceActivityName = "oms.billing.v1.Worker.GenerateInvoice"
	ProcessPaymentActivityName  = "oms.billing.v1.Worker.ProcessPayment"
)

// WorkerClient describes a client for a(n) oms.billing.v1.Worker worker
type WorkerClient interface {
	// durably process an order from a customer
	Charge(ctx context.Context, req *ChargeInput, opts ...*ChargeOptions) (*ChargeResult, error)

	// ChargeAsync starts a(n) billing.v1.Charge workflow and returns a handle to the workflow run
	ChargeAsync(ctx context.Context, req *ChargeInput, opts ...*ChargeOptions) (ChargeRun, error)

	// GetCharge retrieves a handle to an existing billing.v1.Charge workflow execution
	GetCharge(ctx context.Context, workflowID string, runID string) ChargeRun

	// CancelWorkflow requests cancellation of an existing workflow execution
	CancelWorkflow(ctx context.Context, workflowID string, runID string) error

	// TerminateWorkflow an existing workflow execution
	TerminateWorkflow(ctx context.Context, workflowID string, runID string, reason string, details ...interface{}) error
}

// workerClient implements a temporal client for a oms.billing.v1.Worker service
type workerClient struct {
	client client.Client
	log    *slog.Logger
}

// NewWorkerClient initializes a new oms.billing.v1.Worker client
func NewWorkerClient(c client.Client, options ...*workerClientOptions) WorkerClient {
	var cfg *workerClientOptions
	if len(options) > 0 {
		cfg = options[0]
	} else {
		cfg = NewWorkerClientOptions()
	}
	return &workerClient{
		client: c,
		log:    cfg.getLogger(),
	}
}

// NewWorkerClientWithOptions initializes a new Worker client with the given options
func NewWorkerClientWithOptions(c client.Client, opts client.Options, options ...*workerClientOptions) (WorkerClient, error) {
	var err error
	c, err = client.NewClientFromExisting(c, opts)
	if err != nil {
		return nil, fmt.Errorf("error initializing client with options: %w", err)
	}
	var cfg *workerClientOptions
	if len(options) > 0 {
		cfg = options[0]
	} else {
		cfg = NewWorkerClientOptions()
	}
	return &workerClient{
		client: c,
		log:    cfg.getLogger(),
	}, nil
}

// workerClientOptions describes optional runtime configuration for a WorkerClient
type workerClientOptions struct {
	log *slog.Logger
}

// NewWorkerClientOptions initializes a new workerClientOptions value
func NewWorkerClientOptions() *workerClientOptions {
	return &workerClientOptions{}
}

// WithLogger can be used to override the default logger
func (opts *workerClientOptions) WithLogger(l *slog.Logger) *workerClientOptions {
	if l != nil {
		opts.log = l
	}
	return opts
}

// getLogger returns the configured logger, or the default logger
func (opts *workerClientOptions) getLogger() *slog.Logger {
	if opts != nil && opts.log != nil {
		return opts.log
	}
	return slog.Default()
}

// durably process an order from a customer
func (c *workerClient) Charge(ctx context.Context, req *ChargeInput, options ...*ChargeOptions) (*ChargeResult, error) {
	run, err := c.ChargeAsync(ctx, req, options...)
	if err != nil {
		return nil, err
	}
	return run.Get(ctx)
}

// durably process an order from a customer
func (c *workerClient) ChargeAsync(ctx context.Context, req *ChargeInput, options ...*ChargeOptions) (ChargeRun, error) {
	var o *ChargeOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewChargeOptions()
	}
	opts, err := o.Build(req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing client.StartWorkflowOptions: %w", err)
	}
	run, err := c.client.ExecuteWorkflow(ctx, opts, ChargeWorkflowName, req)
	if err != nil {
		return nil, err
	}
	if run == nil {
		return nil, errors.New("execute workflow returned nil run")
	}
	return &chargeRun{
		client: c,
		run:    run,
	}, nil
}

// GetCharge fetches an existing billing.v1.Charge execution
func (c *workerClient) GetCharge(ctx context.Context, workflowID string, runID string) ChargeRun {
	return &chargeRun{
		client: c,
		run:    c.client.GetWorkflow(ctx, workflowID, runID),
	}
}

// CancelWorkflow requests cancellation of an existing workflow execution
func (c *workerClient) CancelWorkflow(ctx context.Context, workflowID string, runID string) error {
	return c.client.CancelWorkflow(ctx, workflowID, runID)
}

// TerminateWorkflow terminates an existing workflow execution
func (c *workerClient) TerminateWorkflow(ctx context.Context, workflowID string, runID string, reason string, details ...interface{}) error {
	return c.client.TerminateWorkflow(ctx, workflowID, runID, reason, details...)
}

// ChargeOptions provides configuration for a billing.v1.Charge workflow operation
type ChargeOptions struct {
	options          client.StartWorkflowOptions
	executionTimeout *time.Duration
	id               *string
	idReusePolicy    enumsv1.WorkflowIdReusePolicy
	retryPolicy      *temporal.RetryPolicy
	runTimeout       *time.Duration
	searchAttributes map[string]any
	taskQueue        *string
	taskTimeout      *time.Duration
}

// NewChargeOptions initializes a new ChargeOptions value
func NewChargeOptions() *ChargeOptions {
	return &ChargeOptions{}
}

// Build initializes a new go.temporal.io/sdk/client.StartWorkflowOptions value with defaults and overrides applied
func (o *ChargeOptions) Build(req protoreflect.Message) (client.StartWorkflowOptions, error) {
	opts := o.options
	if v := o.id; v != nil {
		opts.ID = *v
	} else if opts.ID == "" {
		id, err := expression.EvalExpression(ChargeIdexpression, req)
		if err != nil {
			return opts, fmt.Errorf("error evaluating id expression for %q workflow: %w", ChargeWorkflowName, err)
		}
		opts.ID = id
	}
	if v := o.idReusePolicy; v != enumsv1.WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED {
		opts.WorkflowIDReusePolicy = v
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		opts.TaskQueue = WorkerTaskQueue
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.searchAttributes; v != nil {
		opts.SearchAttributes = o.searchAttributes
	} else if opts.SearchAttributes == nil {
		structured, err := expression.ToStructured(req)
		if err != nil {
			return opts, fmt.Errorf("error serializing input for \"Charge\" search attribute mapping: %v", err)
		}
		result, err := ChargeSearchAttributesMapping.Query(structured)
		if err != nil {
			return opts, fmt.Errorf("error executing \"Charge\" search attribute mapping: %v", err)
		}
		searchAttributes, ok := result.(map[string]any)
		if !ok {
			return opts, fmt.Errorf("expected \"Charge\" search attribute mapping to return map[string]any, got: %T", result)
		}
		opts.SearchAttributes = searchAttributes
	}
	if v := o.executionTimeout; v != nil {
		opts.WorkflowExecutionTimeout = *v
	}
	if v := o.runTimeout; v != nil {
		opts.WorkflowRunTimeout = *v
	}
	if v := o.taskTimeout; v != nil {
		opts.WorkflowTaskTimeout = *v
	}
	return opts, nil
}

// WithStartWorkflowOptions sets the initial go.temporal.io/sdk/client.StartWorkflowOptions
func (o *ChargeOptions) WithStartWorkflowOptions(options client.StartWorkflowOptions) *ChargeOptions {
	o.options = options
	return o
}

// WithExecutionTimeout sets the WorkflowExecutionTimeout value
func (o *ChargeOptions) WithExecutionTimeout(d time.Duration) *ChargeOptions {
	o.executionTimeout = &d
	return o
}

// WithID sets the ID value
func (o *ChargeOptions) WithID(id string) *ChargeOptions {
	o.id = &id
	return o
}

// WithIDReusePolicy sets the WorkflowIDReusePolicy value
func (o *ChargeOptions) WithIDReusePolicy(policy enumsv1.WorkflowIdReusePolicy) *ChargeOptions {
	o.idReusePolicy = policy
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *ChargeOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *ChargeOptions {
	o.retryPolicy = policy
	return o
}

// WithRunTimeout sets the WorkflowRunTimeout value
func (o *ChargeOptions) WithRunTimeout(d time.Duration) *ChargeOptions {
	o.runTimeout = &d
	return o
}

// WithSearchAttributes sets the SearchAttributes value
func (o *ChargeOptions) WithSearchAttributes(sa map[string]any) *ChargeOptions {
	o.searchAttributes = sa
	return o
}

// WithTaskTimeout sets the WorkflowTaskTimeout value
func (o *ChargeOptions) WithTaskTimeout(d time.Duration) *ChargeOptions {
	o.taskTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *ChargeOptions) WithTaskQueue(tq string) *ChargeOptions {
	o.taskQueue = &tq
	return o
}

// ChargeRun describes a(n) billing.v1.Charge workflow run
type ChargeRun interface {
	// ID returns the workflow ID
	ID() string

	// RunID returns the workflow instance ID
	RunID() string

	// Run returns the inner client.WorkflowRun
	Run() client.WorkflowRun

	// Get blocks until the workflow is complete and returns the result
	Get(ctx context.Context) (*ChargeResult, error)

	// Cancel requests cancellation of a workflow in execution, returning an error if applicable
	Cancel(ctx context.Context) error

	// Terminate terminates a workflow in execution, returning an error if applicable
	Terminate(ctx context.Context, reason string, details ...interface{}) error
}

// chargeRun provides an internal implementation of a(n) ChargeRunRun
type chargeRun struct {
	client *workerClient
	run    client.WorkflowRun
}

// ID returns the workflow ID
func (r *chargeRun) ID() string {
	return r.run.GetID()
}

// Run returns the inner client.WorkflowRun
func (r *chargeRun) Run() client.WorkflowRun {
	return r.run
}

// RunID returns the execution ID
func (r *chargeRun) RunID() string {
	return r.run.GetRunID()
}

// Cancel requests cancellation of a workflow in execution, returning an error if applicable
func (r *chargeRun) Cancel(ctx context.Context) error {
	return r.client.CancelWorkflow(ctx, r.ID(), r.RunID())
}

// Get blocks until the workflow is complete, returning the result if applicable
func (r *chargeRun) Get(ctx context.Context) (*ChargeResult, error) {
	var resp ChargeResult
	if err := r.run.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// Terminate terminates a workflow in execution, returning an error if applicable
func (r *chargeRun) Terminate(ctx context.Context, reason string, details ...interface{}) error {
	return r.client.TerminateWorkflow(ctx, r.ID(), r.RunID(), reason, details...)
}

// Reference to generated workflow functions
var (
	// durably process an order from a customer
	ChargeFunction func(workflow.Context, *ChargeInput) (*ChargeResult, error)
)

// WorkerWorkflowFunctions describes a mockable dependency for inlining workflows within other workflows
type (
	// WorkerWorkflowFunctions describes a mockable dependency for inlining workflows within other workflows
	WorkerWorkflowFunctions interface {
		// durably process an order from a customer
		Charge(workflow.Context, *ChargeInput) (*ChargeResult, error)
	}
	// workerWorkflowFunctions provides an internal WorkerWorkflowFunctions implementation
	workerWorkflowFunctions struct{}
)

func NewWorkerWorkflowFunctions() WorkerWorkflowFunctions {
	return &workerWorkflowFunctions{}
}

// durably process an order from a customer
func (f *workerWorkflowFunctions) Charge(ctx workflow.Context, req *ChargeInput) (*ChargeResult, error) {
	if ChargeFunction == nil {
		return nil, errors.New("Charge requires workflow registration via RegisterWorkerWorkflows or RegisterChargeWorkflow")
	}
	return ChargeFunction(ctx, req)
}

// WorkerWorkflows provides methods for initializing new oms.billing.v1.Worker workflow values
type WorkerWorkflows interface {
	// durably process an order from a customer
	Charge(ctx workflow.Context, input *ChargeWorkflowInput) (ChargeWorkflow, error)
}

// RegisterWorkerWorkflows registers oms.billing.v1.Worker workflows with the given worker
func RegisterWorkerWorkflows(r worker.WorkflowRegistry, workflows WorkerWorkflows) {
	RegisterChargeWorkflow(r, workflows.Charge)
}

// RegisterChargeWorkflow registers a oms.billing.v1.Worker.Charge workflow with the given worker
func RegisterChargeWorkflow(r worker.WorkflowRegistry, wf func(workflow.Context, *ChargeWorkflowInput) (ChargeWorkflow, error)) {
	ChargeFunction = buildCharge(wf)
	r.RegisterWorkflowWithOptions(ChargeFunction, workflow.RegisterOptions{Name: ChargeWorkflowName})
}

// buildCharge converts a Charge workflow struct into a valid workflow function
func buildCharge(ctor func(workflow.Context, *ChargeWorkflowInput) (ChargeWorkflow, error)) func(workflow.Context, *ChargeInput) (*ChargeResult, error) {
	return func(ctx workflow.Context, req *ChargeInput) (*ChargeResult, error) {
		input := &ChargeWorkflowInput{
			Req: req,
		}
		wf, err := ctor(ctx, input)
		if err != nil {
			return nil, err
		}
		if initializable, ok := wf.(helpers.Initializable); ok {
			if err := initializable.Initialize(ctx); err != nil {
				return nil, err
			}
		}
		return wf.Execute(ctx)
	}
}

// ChargeWorkflowInput describes the input to a(n) billing.v1.Charge workflow constructor
type ChargeWorkflowInput struct {
	Req *ChargeInput
}

// durably process an order from a customer
//
// workflow details: (name: "billing.v1.Charge", id: "Charge:${! idempotencyKey.or(uuid_v4()) }")
type ChargeWorkflow interface {
	// Execute defines the entrypoint to a(n) billing.v1.Charge workflow
	Execute(ctx workflow.Context) (*ChargeResult, error)
}

// durably process an order from a customer
func ChargeChild(ctx workflow.Context, req *ChargeInput, options ...*ChargeChildOptions) (*ChargeResult, error) {
	childRun, err := ChargeChildAsync(ctx, req, options...)
	if err != nil {
		return nil, err
	}
	return childRun.Get(ctx)
}

// durably process an order from a customer
func ChargeChildAsync(ctx workflow.Context, req *ChargeInput, options ...*ChargeChildOptions) (*ChargeChildRun, error) {
	var o *ChargeChildOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewChargeChildOptions()
	}
	opts, err := o.Build(ctx, req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing workflow.ChildWorkflowOptions: %w", err)
	}
	ctx = workflow.WithChildOptions(ctx, opts)
	return &ChargeChildRun{Future: workflow.ExecuteChildWorkflow(ctx, ChargeWorkflowName, req)}, nil
}

// ChargeChildOptions provides configuration for a child billing.v1.Charge workflow operation
type ChargeChildOptions struct {
	options             workflow.ChildWorkflowOptions
	executionTimeout    *time.Duration
	id                  *string
	idReusePolicy       enumsv1.WorkflowIdReusePolicy
	retryPolicy         *temporal.RetryPolicy
	runTimeout          *time.Duration
	searchAttributes    map[string]any
	taskQueue           *string
	taskTimeout         *time.Duration
	parentClosePolicy   enumsv1.ParentClosePolicy
	waitForCancellation *bool
}

// NewChargeChildOptions initializes a new ChargeChildOptions value
func NewChargeChildOptions() *ChargeChildOptions {
	return &ChargeChildOptions{}
}

// Build initializes a new go.temporal.io/sdk/workflow.ChildWorkflowOptions value with defaults and overrides applied
func (o *ChargeChildOptions) Build(ctx workflow.Context, req protoreflect.Message) (workflow.ChildWorkflowOptions, error) {
	opts := o.options
	if v := o.id; v != nil {
		opts.WorkflowID = *v
	} else if opts.WorkflowID == "" {
		// wrap expression evaluation in local activity
		// more info: https://cludden.github.io/protoc-gen-go-temporal/docs/guides/patches#pv_64-expression-evaluation-local-activity
		if workflow.GetVersion(ctx, "cludden_protoc-gen-go-temporal_64_expression-evaluation-local-activity", workflow.DefaultVersion, 1) == 1 {
			lao := workflow.GetLocalActivityOptions(ctx)
			lao.ScheduleToCloseTimeout = time.Second * 10
			if err := workflow.ExecuteLocalActivity(workflow.WithLocalActivityOptions(ctx, lao), func(ctx context.Context) (string, error) {
				id, err := expression.EvalExpression(ChargeIdexpression, req)
				if err != nil {
					return "", fmt.Errorf("error evaluating id expression for %q workflow: %w", ChargeWorkflowName, err)
				}
				return id, nil
			}).Get(ctx, &opts.WorkflowID); err != nil {
				return opts, fmt.Errorf("error evaluating id expression for %q workflow: %w", ChargeWorkflowName, err)
			}
		} else {
			id, err := expression.EvalExpression(ChargeIdexpression, req)
			if err != nil {
				return opts, fmt.Errorf("error evaluating id expression for %q workflow: %w", ChargeWorkflowName, err)
			}
			opts.WorkflowID = id
		}
	}
	if v := o.idReusePolicy; v != enumsv1.WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED {
		opts.WorkflowIDReusePolicy = v
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		opts.TaskQueue = WorkerTaskQueue
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.searchAttributes; v != nil {
		opts.SearchAttributes = o.searchAttributes
	} else if opts.SearchAttributes == nil {
		// wrap expression evaluation in local activity
		// more info: https://cludden.github.io/protoc-gen-go-temporal/docs/guides/patches#pv_64-expression-evaluation-local-activity
		if workflow.GetVersion(ctx, "cludden_protoc-gen-go-temporal_64_expression-evaluation-local-activity", workflow.DefaultVersion, 1) == 1 {
			lao := workflow.GetLocalActivityOptions(ctx)
			lao.ScheduleToCloseTimeout = time.Second * 10
			if err := workflow.ExecuteLocalActivity(workflow.WithLocalActivityOptions(ctx, lao), func(ctx context.Context) (map[string]any, error) {
				structured, err := expression.ToStructured(req)
				if err != nil {
					return nil, fmt.Errorf("error serializing input for \"Charge\" search attribute mapping: %v", err)
				}
				result, err := ChargeSearchAttributesMapping.Query(structured)
				if err != nil {
					return nil, fmt.Errorf("error executing \"Charge\" search attribute mapping: %v", err)
				}
				searchAttributes, ok := result.(map[string]any)
				if !ok {
					return nil, fmt.Errorf("expected \"Charge\" search attribute mapping to return map[string]any, got: %T", result)
				}
				return searchAttributes, nil
			}).Get(ctx, &opts.SearchAttributes); err != nil {
				return opts, fmt.Errorf("error evaluating search attributes for %q workflow: %w", ChargeWorkflowName, err)
			}
		} else {
			structured, err := expression.ToStructured(req)
			if err != nil {
				return opts, fmt.Errorf("error serializing input for \"Charge\" search attribute mapping: %v", err)
			}
			result, err := ChargeSearchAttributesMapping.Query(structured)
			if err != nil {
				return opts, fmt.Errorf("error executing \"Charge\" search attribute mapping: %v", err)
			}
			searchAttributes, ok := result.(map[string]any)
			if !ok {
				return opts, fmt.Errorf("expected \"Charge\" search attribute mapping to return map[string]any, got: %T", result)
			}
			opts.SearchAttributes = searchAttributes
		}
	}
	if v := o.executionTimeout; v != nil {
		opts.WorkflowExecutionTimeout = *v
	}
	if v := o.runTimeout; v != nil {
		opts.WorkflowRunTimeout = *v
	}
	if v := o.taskTimeout; v != nil {
		opts.WorkflowTaskTimeout = *v
	}
	if v := o.parentClosePolicy; v != enumsv1.PARENT_CLOSE_POLICY_UNSPECIFIED {
		opts.ParentClosePolicy = v
	}
	if v := o.waitForCancellation; v != nil {
		opts.WaitForCancellation = *v
	}
	return opts, nil
}

// WithChildWorkflowOptions sets the initial go.temporal.io/sdk/workflow.ChildWorkflowOptions
func (o *ChargeChildOptions) WithChildWorkflowOptions(options workflow.ChildWorkflowOptions) *ChargeChildOptions {
	o.options = options
	return o
}

// WithExecutionTimeout sets the WorkflowExecutionTimeout value
func (o *ChargeChildOptions) WithExecutionTimeout(d time.Duration) *ChargeChildOptions {
	o.executionTimeout = &d
	return o
}

// WithID sets the WorkflowID value
func (o *ChargeChildOptions) WithID(id string) *ChargeChildOptions {
	o.id = &id
	return o
}

// WithIDReusePolicy sets the WorkflowIDReusePolicy value
func (o *ChargeChildOptions) WithIDReusePolicy(policy enumsv1.WorkflowIdReusePolicy) *ChargeChildOptions {
	o.idReusePolicy = policy
	return o
}

// WithParentClosePolicy sets the WorkflowIDReusePolicy value
func (o *ChargeChildOptions) WithParentClosePolicy(policy enumsv1.ParentClosePolicy) *ChargeChildOptions {
	o.parentClosePolicy = policy
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *ChargeChildOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *ChargeChildOptions {
	o.retryPolicy = policy
	return o
}

// WithRunTimeout sets the WorkflowRunTimeout value
func (o *ChargeChildOptions) WithRunTimeout(d time.Duration) *ChargeChildOptions {
	o.runTimeout = &d
	return o
}

// WithSearchAttributes sets the SearchAttributes value
func (o *ChargeChildOptions) WithSearchAttributes(sa map[string]any) *ChargeChildOptions {
	o.searchAttributes = sa
	return o
}

// WithTaskTimeout sets the WorkflowTaskTimeout value
func (o *ChargeChildOptions) WithTaskTimeout(d time.Duration) *ChargeChildOptions {
	o.taskTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *ChargeChildOptions) WithTaskQueue(tq string) *ChargeChildOptions {
	o.taskQueue = &tq
	return o
}

// WithWaitForCancellation sets the WaitForCancellation value
func (o *ChargeChildOptions) WithWaitForCancellation(wait bool) *ChargeChildOptions {
	o.waitForCancellation = &wait
	return o
}

// ChargeChildRun describes a child Charge workflow run
type ChargeChildRun struct {
	Future workflow.ChildWorkflowFuture
}

// Get blocks until the workflow is completed, returning the response value
func (r *ChargeChildRun) Get(ctx workflow.Context) (*ChargeResult, error) {
	var resp ChargeResult
	if err := r.Future.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// Select adds this completion to the selector. Callback can be nil.
func (r *ChargeChildRun) Select(sel workflow.Selector, fn func(*ChargeChildRun)) workflow.Selector {
	return sel.AddFuture(r.Future, func(workflow.Future) {
		if fn != nil {
			fn(r)
		}
	})
}

// SelectStart adds waiting for start to the selector. Callback can be nil.
func (r *ChargeChildRun) SelectStart(sel workflow.Selector, fn func(*ChargeChildRun)) workflow.Selector {
	return sel.AddFuture(r.Future.GetChildWorkflowExecution(), func(workflow.Future) {
		if fn != nil {
			fn(r)
		}
	})
}

// WaitStart waits for the child workflow to start
func (r *ChargeChildRun) WaitStart(ctx workflow.Context) (*workflow.Execution, error) {
	var exec workflow.Execution
	if err := r.Future.GetChildWorkflowExecution().Get(ctx, &exec); err != nil {
		return nil, err
	}
	return &exec, nil
}

// WorkerActivities describes available worker activities
type WorkerActivities interface {
	// determines whether the charge is fraudulent
	CheckFraud(ctx context.Context, req *CheckFraudInput) (*CheckFraudResult, error)

	// generates an invoice file
	GenerateInvoice(ctx context.Context, req *GenerateInvoiceInput) (*GenerateInvoiceResult, error)

	// processes the customer payment
	ProcessPayment(ctx context.Context, req *ProcessPaymentInput) (*ProcessPaymentResult, error)
}

// RegisterWorkerActivities registers activities with a worker
func RegisterWorkerActivities(r worker.ActivityRegistry, activities WorkerActivities) {
	RegisterCheckFraudActivity(r, activities.CheckFraud)
	RegisterGenerateInvoiceActivity(r, activities.GenerateInvoice)
	RegisterProcessPaymentActivity(r, activities.ProcessPayment)
}

// RegisterCheckFraudActivity registers a oms.billing.v1.Worker.CheckFraud activity
func RegisterCheckFraudActivity(r worker.ActivityRegistry, fn func(context.Context, *CheckFraudInput) (*CheckFraudResult, error)) {
	r.RegisterActivityWithOptions(fn, activity.RegisterOptions{
		Name: CheckFraudActivityName,
	})
}

// CheckFraudFuture describes a(n) oms.billing.v1.Worker.CheckFraud activity execution
type CheckFraudFuture struct {
	Future workflow.Future
}

// Get blocks on the activity's completion, returning the response
func (f *CheckFraudFuture) Get(ctx workflow.Context) (*CheckFraudResult, error) {
	var resp CheckFraudResult
	if err := f.Future.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// Select adds the activity's completion to the selector, callback can be nil
func (f *CheckFraudFuture) Select(sel workflow.Selector, fn func(*CheckFraudFuture)) workflow.Selector {
	return sel.AddFuture(f.Future, func(workflow.Future) {
		if fn != nil {
			fn(f)
		}
	})
}

// determines whether the charge is fraudulent
func CheckFraud(ctx workflow.Context, req *CheckFraudInput, options ...*CheckFraudActivityOptions) (*CheckFraudResult, error) {
	return CheckFraudAsync(ctx, req, options...).Get(ctx)
}

// determines whether the charge is fraudulent
func CheckFraudAsync(ctx workflow.Context, req *CheckFraudInput, options ...*CheckFraudActivityOptions) *CheckFraudFuture {
	var o *CheckFraudActivityOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewCheckFraudActivityOptions()
	}
	var err error
	if ctx, err = o.Build(ctx); err != nil {
		errF, errS := workflow.NewFuture(ctx)
		errS.SetError(err)
		return &CheckFraudFuture{Future: errF}
	}
	activity := CheckFraudActivityName
	future := &CheckFraudFuture{Future: workflow.ExecuteActivity(ctx, activity, req)}
	return future
}

// determines whether the charge is fraudulent
func CheckFraudLocal(ctx workflow.Context, req *CheckFraudInput, options ...*CheckFraudLocalActivityOptions) (*CheckFraudResult, error) {
	return CheckFraudLocalAsync(ctx, req, options...).Get(ctx)
}

// determines whether the charge is fraudulent
func CheckFraudLocalAsync(ctx workflow.Context, req *CheckFraudInput, options ...*CheckFraudLocalActivityOptions) *CheckFraudFuture {
	var o *CheckFraudLocalActivityOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewCheckFraudLocalActivityOptions()
	}
	var err error
	if ctx, err = o.Build(ctx); err != nil {
		errF, errS := workflow.NewFuture(ctx)
		errS.SetError(err)
		return &CheckFraudFuture{Future: errF}
	}
	var activity any
	if o.fn != nil {
		activity = o.fn
	} else {
		activity = CheckFraudActivityName
	}
	future := &CheckFraudFuture{Future: workflow.ExecuteLocalActivity(ctx, activity, req)}
	return future
}

// CheckFraudActivityOptions provides configuration for a(n) oms.billing.v1.Worker.CheckFraud activity
type CheckFraudActivityOptions struct {
	options                workflow.ActivityOptions
	retryPolicy            *temporal.RetryPolicy
	scheduleToCloseTimeout *time.Duration
	startToCloseTimeout    *time.Duration
	heartbeatTimeout       *time.Duration
	scheduleToStartTimeout *time.Duration
	taskQueue              *string
	waitForCancellation    *bool
}

// NewCheckFraudActivityOptions initializes a new CheckFraudActivityOptions value
func NewCheckFraudActivityOptions() *CheckFraudActivityOptions {
	return &CheckFraudActivityOptions{}
}

// Build initializes a workflow.Context with appropriate ActivityOptions values derived from schema defaults and any user-defined overrides
func (o *CheckFraudActivityOptions) Build(ctx workflow.Context) (workflow.Context, error) {
	opts := o.options
	if v := o.heartbeatTimeout; v != nil {
		opts.HeartbeatTimeout = *v
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	} else if opts.RetryPolicy == nil {
		opts.RetryPolicy = &temporal.RetryPolicy{InitialInterval: 5000000000, MaximumInterval: 5000000000}
	}
	if v := o.scheduleToCloseTimeout; v != nil {
		opts.ScheduleToCloseTimeout = *v
	}
	if v := o.scheduleToStartTimeout; v != nil {
		opts.ScheduleToStartTimeout = *v
	}
	if v := o.startToCloseTimeout; v != nil {
		opts.StartToCloseTimeout = *v
	} else if opts.StartToCloseTimeout == 0 {
		opts.StartToCloseTimeout = 300000000000 // 5 minutes
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		opts.TaskQueue = WorkerTaskQueue
	}
	if v := o.waitForCancellation; v != nil {
		opts.WaitForCancellation = *v
	}
	return workflow.WithActivityOptions(ctx, opts), nil
}

// WithActivityOptions specifies an initial ActivityOptions value to which defaults will be applied
func (o *CheckFraudActivityOptions) WithActivityOptions(options workflow.ActivityOptions) *CheckFraudActivityOptions {
	o.options = options
	return o
}

// WithHeartbeatTimeout sets the HeartbeatTimeout value
func (o *CheckFraudActivityOptions) WithHeartbeatTimeout(d time.Duration) *CheckFraudActivityOptions {
	o.heartbeatTimeout = &d
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *CheckFraudActivityOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *CheckFraudActivityOptions {
	o.retryPolicy = policy
	return o
}

// WithScheduleToCloseTimeout sets the ScheduleToCloseTimeout value
func (o *CheckFraudActivityOptions) WithScheduleToCloseTimeout(d time.Duration) *CheckFraudActivityOptions {
	o.scheduleToCloseTimeout = &d
	return o
}

// WithScheduleToStartTimeout sets the ScheduleToStartTimeout value
func (o *CheckFraudActivityOptions) WithScheduleToStartTimeout(d time.Duration) *CheckFraudActivityOptions {
	o.scheduleToStartTimeout = &d
	return o
}

// WithStartToCloseTimeout sets the StartToCloseTimeout value
func (o *CheckFraudActivityOptions) WithStartToCloseTimeout(d time.Duration) *CheckFraudActivityOptions {
	o.startToCloseTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *CheckFraudActivityOptions) WithTaskQueue(tq string) *CheckFraudActivityOptions {
	o.taskQueue = &tq
	return o
}

// WithWaitForCancellation sets the WaitForCancellation value
func (o *CheckFraudActivityOptions) WithWaitForCancellation(wait bool) *CheckFraudActivityOptions {
	o.waitForCancellation = &wait
	return o
}

// CheckFraudLocalActivityOptions provides configuration for a(n) oms.billing.v1.Worker.CheckFraud activity
type CheckFraudLocalActivityOptions struct {
	options                workflow.LocalActivityOptions
	retryPolicy            *temporal.RetryPolicy
	scheduleToCloseTimeout *time.Duration
	startToCloseTimeout    *time.Duration
	fn                     func(context.Context, *CheckFraudInput) (*CheckFraudResult, error)
}

// NewCheckFraudLocalActivityOptions initializes a new CheckFraudLocalActivityOptions value
func NewCheckFraudLocalActivityOptions() *CheckFraudLocalActivityOptions {
	return &CheckFraudLocalActivityOptions{}
}

// Build initializes a workflow.Context with appropriate LocalActivityOptions values derived from schema defaults and any user-defined overrides
func (o *CheckFraudLocalActivityOptions) Build(ctx workflow.Context) (workflow.Context, error) {
	opts := o.options
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	} else if opts.RetryPolicy == nil {
		opts.RetryPolicy = &temporal.RetryPolicy{InitialInterval: 5000000000, MaximumInterval: 5000000000}
	}
	if v := o.scheduleToCloseTimeout; v != nil {
		opts.ScheduleToCloseTimeout = *v
	}
	if v := o.startToCloseTimeout; v != nil {
		opts.StartToCloseTimeout = *v
	} else if opts.StartToCloseTimeout == 0 {
		opts.StartToCloseTimeout = 300000000000 // 5 minutes
	}
	return workflow.WithLocalActivityOptions(ctx, opts), nil
}

// Local specifies a custom oms.billing.v1.Worker.CheckFraud implementation
func (o *CheckFraudLocalActivityOptions) Local(fn func(context.Context, *CheckFraudInput) (*CheckFraudResult, error)) *CheckFraudLocalActivityOptions {
	o.fn = fn
	return o
}

// WithLocalActivityOptions specifies an initial LocalActivityOptions value to which defaults will be applied
func (o *CheckFraudLocalActivityOptions) WithLocalActivityOptions(options workflow.LocalActivityOptions) *CheckFraudLocalActivityOptions {
	o.options = options
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *CheckFraudLocalActivityOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *CheckFraudLocalActivityOptions {
	o.retryPolicy = policy
	return o
}

// WithScheduleToCloseTimeout sets the ScheduleToCloseTimeout value
func (o *CheckFraudLocalActivityOptions) WithScheduleToCloseTimeout(d time.Duration) *CheckFraudLocalActivityOptions {
	o.scheduleToCloseTimeout = &d
	return o
}

// WithStartToCloseTimeout sets the StartToCloseTimeout value
func (o *CheckFraudLocalActivityOptions) WithStartToCloseTimeout(d time.Duration) *CheckFraudLocalActivityOptions {
	o.startToCloseTimeout = &d
	return o
}

// RegisterGenerateInvoiceActivity registers a oms.billing.v1.Worker.GenerateInvoice activity
func RegisterGenerateInvoiceActivity(r worker.ActivityRegistry, fn func(context.Context, *GenerateInvoiceInput) (*GenerateInvoiceResult, error)) {
	r.RegisterActivityWithOptions(fn, activity.RegisterOptions{
		Name: GenerateInvoiceActivityName,
	})
}

// GenerateInvoiceFuture describes a(n) oms.billing.v1.Worker.GenerateInvoice activity execution
type GenerateInvoiceFuture struct {
	Future workflow.Future
}

// Get blocks on the activity's completion, returning the response
func (f *GenerateInvoiceFuture) Get(ctx workflow.Context) (*GenerateInvoiceResult, error) {
	var resp GenerateInvoiceResult
	if err := f.Future.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// Select adds the activity's completion to the selector, callback can be nil
func (f *GenerateInvoiceFuture) Select(sel workflow.Selector, fn func(*GenerateInvoiceFuture)) workflow.Selector {
	return sel.AddFuture(f.Future, func(workflow.Future) {
		if fn != nil {
			fn(f)
		}
	})
}

// generates an invoice file
func GenerateInvoice(ctx workflow.Context, req *GenerateInvoiceInput, options ...*GenerateInvoiceActivityOptions) (*GenerateInvoiceResult, error) {
	return GenerateInvoiceAsync(ctx, req, options...).Get(ctx)
}

// generates an invoice file
func GenerateInvoiceAsync(ctx workflow.Context, req *GenerateInvoiceInput, options ...*GenerateInvoiceActivityOptions) *GenerateInvoiceFuture {
	var o *GenerateInvoiceActivityOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewGenerateInvoiceActivityOptions()
	}
	var err error
	if ctx, err = o.Build(ctx); err != nil {
		errF, errS := workflow.NewFuture(ctx)
		errS.SetError(err)
		return &GenerateInvoiceFuture{Future: errF}
	}
	activity := GenerateInvoiceActivityName
	future := &GenerateInvoiceFuture{Future: workflow.ExecuteActivity(ctx, activity, req)}
	return future
}

// generates an invoice file
func GenerateInvoiceLocal(ctx workflow.Context, req *GenerateInvoiceInput, options ...*GenerateInvoiceLocalActivityOptions) (*GenerateInvoiceResult, error) {
	return GenerateInvoiceLocalAsync(ctx, req, options...).Get(ctx)
}

// generates an invoice file
func GenerateInvoiceLocalAsync(ctx workflow.Context, req *GenerateInvoiceInput, options ...*GenerateInvoiceLocalActivityOptions) *GenerateInvoiceFuture {
	var o *GenerateInvoiceLocalActivityOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewGenerateInvoiceLocalActivityOptions()
	}
	var err error
	if ctx, err = o.Build(ctx); err != nil {
		errF, errS := workflow.NewFuture(ctx)
		errS.SetError(err)
		return &GenerateInvoiceFuture{Future: errF}
	}
	var activity any
	if o.fn != nil {
		activity = o.fn
	} else {
		activity = GenerateInvoiceActivityName
	}
	future := &GenerateInvoiceFuture{Future: workflow.ExecuteLocalActivity(ctx, activity, req)}
	return future
}

// GenerateInvoiceActivityOptions provides configuration for a(n) oms.billing.v1.Worker.GenerateInvoice activity
type GenerateInvoiceActivityOptions struct {
	options                workflow.ActivityOptions
	retryPolicy            *temporal.RetryPolicy
	scheduleToCloseTimeout *time.Duration
	startToCloseTimeout    *time.Duration
	heartbeatTimeout       *time.Duration
	scheduleToStartTimeout *time.Duration
	taskQueue              *string
	waitForCancellation    *bool
}

// NewGenerateInvoiceActivityOptions initializes a new GenerateInvoiceActivityOptions value
func NewGenerateInvoiceActivityOptions() *GenerateInvoiceActivityOptions {
	return &GenerateInvoiceActivityOptions{}
}

// Build initializes a workflow.Context with appropriate ActivityOptions values derived from schema defaults and any user-defined overrides
func (o *GenerateInvoiceActivityOptions) Build(ctx workflow.Context) (workflow.Context, error) {
	opts := o.options
	if v := o.heartbeatTimeout; v != nil {
		opts.HeartbeatTimeout = *v
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.scheduleToCloseTimeout; v != nil {
		opts.ScheduleToCloseTimeout = *v
	} else if opts.ScheduleToCloseTimeout == 0 {
		opts.ScheduleToCloseTimeout = 30000000000 // 30 seconds
	}
	if v := o.scheduleToStartTimeout; v != nil {
		opts.ScheduleToStartTimeout = *v
	}
	if v := o.startToCloseTimeout; v != nil {
		opts.StartToCloseTimeout = *v
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		opts.TaskQueue = WorkerTaskQueue
	}
	if v := o.waitForCancellation; v != nil {
		opts.WaitForCancellation = *v
	}
	return workflow.WithActivityOptions(ctx, opts), nil
}

// WithActivityOptions specifies an initial ActivityOptions value to which defaults will be applied
func (o *GenerateInvoiceActivityOptions) WithActivityOptions(options workflow.ActivityOptions) *GenerateInvoiceActivityOptions {
	o.options = options
	return o
}

// WithHeartbeatTimeout sets the HeartbeatTimeout value
func (o *GenerateInvoiceActivityOptions) WithHeartbeatTimeout(d time.Duration) *GenerateInvoiceActivityOptions {
	o.heartbeatTimeout = &d
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *GenerateInvoiceActivityOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *GenerateInvoiceActivityOptions {
	o.retryPolicy = policy
	return o
}

// WithScheduleToCloseTimeout sets the ScheduleToCloseTimeout value
func (o *GenerateInvoiceActivityOptions) WithScheduleToCloseTimeout(d time.Duration) *GenerateInvoiceActivityOptions {
	o.scheduleToCloseTimeout = &d
	return o
}

// WithScheduleToStartTimeout sets the ScheduleToStartTimeout value
func (o *GenerateInvoiceActivityOptions) WithScheduleToStartTimeout(d time.Duration) *GenerateInvoiceActivityOptions {
	o.scheduleToStartTimeout = &d
	return o
}

// WithStartToCloseTimeout sets the StartToCloseTimeout value
func (o *GenerateInvoiceActivityOptions) WithStartToCloseTimeout(d time.Duration) *GenerateInvoiceActivityOptions {
	o.startToCloseTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *GenerateInvoiceActivityOptions) WithTaskQueue(tq string) *GenerateInvoiceActivityOptions {
	o.taskQueue = &tq
	return o
}

// WithWaitForCancellation sets the WaitForCancellation value
func (o *GenerateInvoiceActivityOptions) WithWaitForCancellation(wait bool) *GenerateInvoiceActivityOptions {
	o.waitForCancellation = &wait
	return o
}

// GenerateInvoiceLocalActivityOptions provides configuration for a(n) oms.billing.v1.Worker.GenerateInvoice activity
type GenerateInvoiceLocalActivityOptions struct {
	options                workflow.LocalActivityOptions
	retryPolicy            *temporal.RetryPolicy
	scheduleToCloseTimeout *time.Duration
	startToCloseTimeout    *time.Duration
	fn                     func(context.Context, *GenerateInvoiceInput) (*GenerateInvoiceResult, error)
}

// NewGenerateInvoiceLocalActivityOptions initializes a new GenerateInvoiceLocalActivityOptions value
func NewGenerateInvoiceLocalActivityOptions() *GenerateInvoiceLocalActivityOptions {
	return &GenerateInvoiceLocalActivityOptions{}
}

// Build initializes a workflow.Context with appropriate LocalActivityOptions values derived from schema defaults and any user-defined overrides
func (o *GenerateInvoiceLocalActivityOptions) Build(ctx workflow.Context) (workflow.Context, error) {
	opts := o.options
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.scheduleToCloseTimeout; v != nil {
		opts.ScheduleToCloseTimeout = *v
	} else if opts.ScheduleToCloseTimeout == 0 {
		opts.ScheduleToCloseTimeout = 30000000000 // 30 seconds
	}
	if v := o.startToCloseTimeout; v != nil {
		opts.StartToCloseTimeout = *v
	}
	return workflow.WithLocalActivityOptions(ctx, opts), nil
}

// Local specifies a custom oms.billing.v1.Worker.GenerateInvoice implementation
func (o *GenerateInvoiceLocalActivityOptions) Local(fn func(context.Context, *GenerateInvoiceInput) (*GenerateInvoiceResult, error)) *GenerateInvoiceLocalActivityOptions {
	o.fn = fn
	return o
}

// WithLocalActivityOptions specifies an initial LocalActivityOptions value to which defaults will be applied
func (o *GenerateInvoiceLocalActivityOptions) WithLocalActivityOptions(options workflow.LocalActivityOptions) *GenerateInvoiceLocalActivityOptions {
	o.options = options
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *GenerateInvoiceLocalActivityOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *GenerateInvoiceLocalActivityOptions {
	o.retryPolicy = policy
	return o
}

// WithScheduleToCloseTimeout sets the ScheduleToCloseTimeout value
func (o *GenerateInvoiceLocalActivityOptions) WithScheduleToCloseTimeout(d time.Duration) *GenerateInvoiceLocalActivityOptions {
	o.scheduleToCloseTimeout = &d
	return o
}

// WithStartToCloseTimeout sets the StartToCloseTimeout value
func (o *GenerateInvoiceLocalActivityOptions) WithStartToCloseTimeout(d time.Duration) *GenerateInvoiceLocalActivityOptions {
	o.startToCloseTimeout = &d
	return o
}

// RegisterProcessPaymentActivity registers a oms.billing.v1.Worker.ProcessPayment activity
func RegisterProcessPaymentActivity(r worker.ActivityRegistry, fn func(context.Context, *ProcessPaymentInput) (*ProcessPaymentResult, error)) {
	r.RegisterActivityWithOptions(fn, activity.RegisterOptions{
		Name: ProcessPaymentActivityName,
	})
}

// ProcessPaymentFuture describes a(n) oms.billing.v1.Worker.ProcessPayment activity execution
type ProcessPaymentFuture struct {
	Future workflow.Future
}

// Get blocks on the activity's completion, returning the response
func (f *ProcessPaymentFuture) Get(ctx workflow.Context) (*ProcessPaymentResult, error) {
	var resp ProcessPaymentResult
	if err := f.Future.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// Select adds the activity's completion to the selector, callback can be nil
func (f *ProcessPaymentFuture) Select(sel workflow.Selector, fn func(*ProcessPaymentFuture)) workflow.Selector {
	return sel.AddFuture(f.Future, func(workflow.Future) {
		if fn != nil {
			fn(f)
		}
	})
}

// processes the customer payment
func ProcessPayment(ctx workflow.Context, req *ProcessPaymentInput, options ...*ProcessPaymentActivityOptions) (*ProcessPaymentResult, error) {
	return ProcessPaymentAsync(ctx, req, options...).Get(ctx)
}

// processes the customer payment
func ProcessPaymentAsync(ctx workflow.Context, req *ProcessPaymentInput, options ...*ProcessPaymentActivityOptions) *ProcessPaymentFuture {
	var o *ProcessPaymentActivityOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewProcessPaymentActivityOptions()
	}
	var err error
	if ctx, err = o.Build(ctx); err != nil {
		errF, errS := workflow.NewFuture(ctx)
		errS.SetError(err)
		return &ProcessPaymentFuture{Future: errF}
	}
	activity := ProcessPaymentActivityName
	future := &ProcessPaymentFuture{Future: workflow.ExecuteActivity(ctx, activity, req)}
	return future
}

// processes the customer payment
func ProcessPaymentLocal(ctx workflow.Context, req *ProcessPaymentInput, options ...*ProcessPaymentLocalActivityOptions) (*ProcessPaymentResult, error) {
	return ProcessPaymentLocalAsync(ctx, req, options...).Get(ctx)
}

// processes the customer payment
func ProcessPaymentLocalAsync(ctx workflow.Context, req *ProcessPaymentInput, options ...*ProcessPaymentLocalActivityOptions) *ProcessPaymentFuture {
	var o *ProcessPaymentLocalActivityOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewProcessPaymentLocalActivityOptions()
	}
	var err error
	if ctx, err = o.Build(ctx); err != nil {
		errF, errS := workflow.NewFuture(ctx)
		errS.SetError(err)
		return &ProcessPaymentFuture{Future: errF}
	}
	var activity any
	if o.fn != nil {
		activity = o.fn
	} else {
		activity = ProcessPaymentActivityName
	}
	future := &ProcessPaymentFuture{Future: workflow.ExecuteLocalActivity(ctx, activity, req)}
	return future
}

// ProcessPaymentActivityOptions provides configuration for a(n) oms.billing.v1.Worker.ProcessPayment activity
type ProcessPaymentActivityOptions struct {
	options                workflow.ActivityOptions
	retryPolicy            *temporal.RetryPolicy
	scheduleToCloseTimeout *time.Duration
	startToCloseTimeout    *time.Duration
	heartbeatTimeout       *time.Duration
	scheduleToStartTimeout *time.Duration
	taskQueue              *string
	waitForCancellation    *bool
}

// NewProcessPaymentActivityOptions initializes a new ProcessPaymentActivityOptions value
func NewProcessPaymentActivityOptions() *ProcessPaymentActivityOptions {
	return &ProcessPaymentActivityOptions{}
}

// Build initializes a workflow.Context with appropriate ActivityOptions values derived from schema defaults and any user-defined overrides
func (o *ProcessPaymentActivityOptions) Build(ctx workflow.Context) (workflow.Context, error) {
	opts := o.options
	if v := o.heartbeatTimeout; v != nil {
		opts.HeartbeatTimeout = *v
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.scheduleToCloseTimeout; v != nil {
		opts.ScheduleToCloseTimeout = *v
	}
	if v := o.scheduleToStartTimeout; v != nil {
		opts.ScheduleToStartTimeout = *v
	}
	if v := o.startToCloseTimeout; v != nil {
		opts.StartToCloseTimeout = *v
	} else if opts.StartToCloseTimeout == 0 {
		opts.StartToCloseTimeout = 120000000000 // 2 minutes
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		opts.TaskQueue = WorkerTaskQueue
	}
	if v := o.waitForCancellation; v != nil {
		opts.WaitForCancellation = *v
	}
	return workflow.WithActivityOptions(ctx, opts), nil
}

// WithActivityOptions specifies an initial ActivityOptions value to which defaults will be applied
func (o *ProcessPaymentActivityOptions) WithActivityOptions(options workflow.ActivityOptions) *ProcessPaymentActivityOptions {
	o.options = options
	return o
}

// WithHeartbeatTimeout sets the HeartbeatTimeout value
func (o *ProcessPaymentActivityOptions) WithHeartbeatTimeout(d time.Duration) *ProcessPaymentActivityOptions {
	o.heartbeatTimeout = &d
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *ProcessPaymentActivityOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *ProcessPaymentActivityOptions {
	o.retryPolicy = policy
	return o
}

// WithScheduleToCloseTimeout sets the ScheduleToCloseTimeout value
func (o *ProcessPaymentActivityOptions) WithScheduleToCloseTimeout(d time.Duration) *ProcessPaymentActivityOptions {
	o.scheduleToCloseTimeout = &d
	return o
}

// WithScheduleToStartTimeout sets the ScheduleToStartTimeout value
func (o *ProcessPaymentActivityOptions) WithScheduleToStartTimeout(d time.Duration) *ProcessPaymentActivityOptions {
	o.scheduleToStartTimeout = &d
	return o
}

// WithStartToCloseTimeout sets the StartToCloseTimeout value
func (o *ProcessPaymentActivityOptions) WithStartToCloseTimeout(d time.Duration) *ProcessPaymentActivityOptions {
	o.startToCloseTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *ProcessPaymentActivityOptions) WithTaskQueue(tq string) *ProcessPaymentActivityOptions {
	o.taskQueue = &tq
	return o
}

// WithWaitForCancellation sets the WaitForCancellation value
func (o *ProcessPaymentActivityOptions) WithWaitForCancellation(wait bool) *ProcessPaymentActivityOptions {
	o.waitForCancellation = &wait
	return o
}

// ProcessPaymentLocalActivityOptions provides configuration for a(n) oms.billing.v1.Worker.ProcessPayment activity
type ProcessPaymentLocalActivityOptions struct {
	options                workflow.LocalActivityOptions
	retryPolicy            *temporal.RetryPolicy
	scheduleToCloseTimeout *time.Duration
	startToCloseTimeout    *time.Duration
	fn                     func(context.Context, *ProcessPaymentInput) (*ProcessPaymentResult, error)
}

// NewProcessPaymentLocalActivityOptions initializes a new ProcessPaymentLocalActivityOptions value
func NewProcessPaymentLocalActivityOptions() *ProcessPaymentLocalActivityOptions {
	return &ProcessPaymentLocalActivityOptions{}
}

// Build initializes a workflow.Context with appropriate LocalActivityOptions values derived from schema defaults and any user-defined overrides
func (o *ProcessPaymentLocalActivityOptions) Build(ctx workflow.Context) (workflow.Context, error) {
	opts := o.options
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.scheduleToCloseTimeout; v != nil {
		opts.ScheduleToCloseTimeout = *v
	}
	if v := o.startToCloseTimeout; v != nil {
		opts.StartToCloseTimeout = *v
	} else if opts.StartToCloseTimeout == 0 {
		opts.StartToCloseTimeout = 120000000000 // 2 minutes
	}
	return workflow.WithLocalActivityOptions(ctx, opts), nil
}

// Local specifies a custom oms.billing.v1.Worker.ProcessPayment implementation
func (o *ProcessPaymentLocalActivityOptions) Local(fn func(context.Context, *ProcessPaymentInput) (*ProcessPaymentResult, error)) *ProcessPaymentLocalActivityOptions {
	o.fn = fn
	return o
}

// WithLocalActivityOptions specifies an initial LocalActivityOptions value to which defaults will be applied
func (o *ProcessPaymentLocalActivityOptions) WithLocalActivityOptions(options workflow.LocalActivityOptions) *ProcessPaymentLocalActivityOptions {
	o.options = options
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *ProcessPaymentLocalActivityOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *ProcessPaymentLocalActivityOptions {
	o.retryPolicy = policy
	return o
}

// WithScheduleToCloseTimeout sets the ScheduleToCloseTimeout value
func (o *ProcessPaymentLocalActivityOptions) WithScheduleToCloseTimeout(d time.Duration) *ProcessPaymentLocalActivityOptions {
	o.scheduleToCloseTimeout = &d
	return o
}

// WithStartToCloseTimeout sets the StartToCloseTimeout value
func (o *ProcessPaymentLocalActivityOptions) WithStartToCloseTimeout(d time.Duration) *ProcessPaymentLocalActivityOptions {
	o.startToCloseTimeout = &d
	return o
}

// TestClient provides a testsuite-compatible Client
type TestWorkerClient struct {
	env       *testsuite.TestWorkflowEnvironment
	workflows WorkerWorkflows
}

var _ WorkerClient = &TestWorkerClient{}

// NewTestWorkerClient initializes a new TestWorkerClient value
func NewTestWorkerClient(env *testsuite.TestWorkflowEnvironment, workflows WorkerWorkflows, activities WorkerActivities) *TestWorkerClient {
	if workflows != nil {
		RegisterWorkerWorkflows(env, workflows)
	}
	if activities != nil {
		RegisterWorkerActivities(env, activities)
	}
	return &TestWorkerClient{env, workflows}
}

// Charge executes a(n) billing.v1.Charge workflow in the test environment
func (c *TestWorkerClient) Charge(ctx context.Context, req *ChargeInput, opts ...*ChargeOptions) (*ChargeResult, error) {
	run, err := c.ChargeAsync(ctx, req, opts...)
	if err != nil {
		return nil, err
	}
	return run.Get(ctx)
}

// ChargeAsync executes a(n) billing.v1.Charge workflow in the test environment
func (c *TestWorkerClient) ChargeAsync(ctx context.Context, req *ChargeInput, options ...*ChargeOptions) (ChargeRun, error) {
	var o *ChargeOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewChargeOptions()
	}
	opts, err := o.Build(req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing client.StartWorkflowOptions: %w", err)
	}
	return &testChargeRun{client: c, env: c.env, opts: &opts, req: req, workflows: c.workflows}, nil
}

// GetCharge is a noop
func (c *TestWorkerClient) GetCharge(ctx context.Context, workflowID string, runID string) ChargeRun {
	return &testChargeRun{env: c.env, workflows: c.workflows}
}

// CancelWorkflow requests cancellation of an existing workflow execution
func (c *TestWorkerClient) CancelWorkflow(ctx context.Context, workflowID string, runID string) error {
	c.env.CancelWorkflow()
	return nil
}

// TerminateWorkflow terminates an existing workflow execution
func (c *TestWorkerClient) TerminateWorkflow(ctx context.Context, workflowID string, runID string, reason string, details ...interface{}) error {
	return c.CancelWorkflow(ctx, workflowID, runID)
}

var _ ChargeRun = &testChargeRun{}

// testChargeRun provides convenience methods for interacting with a(n) billing.v1.Charge workflow in the test environment
type testChargeRun struct {
	client    *TestWorkerClient
	env       *testsuite.TestWorkflowEnvironment
	opts      *client.StartWorkflowOptions
	req       *ChargeInput
	workflows WorkerWorkflows
}

// Cancel requests cancellation of a workflow in execution, returning an error if applicable
func (r *testChargeRun) Cancel(ctx context.Context) error {
	return r.client.CancelWorkflow(ctx, r.ID(), r.RunID())
}

// Get retrieves a test billing.v1.Charge workflow result
func (r *testChargeRun) Get(context.Context) (*ChargeResult, error) {
	r.env.ExecuteWorkflow(ChargeWorkflowName, r.req)
	if !r.env.IsWorkflowCompleted() {
		return nil, errors.New("workflow in progress")
	}
	if err := r.env.GetWorkflowError(); err != nil {
		return nil, err
	}
	var result ChargeResult
	if err := r.env.GetWorkflowResult(&result); err != nil {
		return nil, err
	}
	return &result, nil
}

// ID returns a test billing.v1.Charge workflow run's workflow ID
func (r *testChargeRun) ID() string {
	if r.opts != nil {
		return r.opts.ID
	}
	return ""
}

// Run noop implementation
func (r *testChargeRun) Run() client.WorkflowRun {
	return nil
}

// RunID noop implementation
func (r *testChargeRun) RunID() string {
	return ""
}

// Terminate terminates a workflow in execution, returning an error if applicable
func (r *testChargeRun) Terminate(ctx context.Context, reason string, details ...interface{}) error {
	return r.client.TerminateWorkflow(ctx, r.ID(), r.RunID(), reason, details...)
}

// WorkerCliOptions describes runtime configuration for oms.billing.v1.Worker cli
type WorkerCliOptions struct {
	after            func(*v2.Context) error
	before           func(*v2.Context) error
	clientForCommand func(*v2.Context) (client.Client, error)
	worker           func(*v2.Context, client.Client) (worker.Worker, error)
}

// NewWorkerCliOptions initializes a new WorkerCliOptions value
func NewWorkerCliOptions() *WorkerCliOptions {
	return &WorkerCliOptions{}
}

// WithAfter injects a custom After hook to be run after any command invocation
func (opts *WorkerCliOptions) WithAfter(fn func(*v2.Context) error) *WorkerCliOptions {
	opts.after = fn
	return opts
}

// WithBefore injects a custom Before hook to be run prior to any command invocation
func (opts *WorkerCliOptions) WithBefore(fn func(*v2.Context) error) *WorkerCliOptions {
	opts.before = fn
	return opts
}

// WithClient provides a Temporal client factory for use by commands
func (opts *WorkerCliOptions) WithClient(fn func(*v2.Context) (client.Client, error)) *WorkerCliOptions {
	opts.clientForCommand = fn
	return opts
}

// WithWorker provides an method for initializing a worker
func (opts *WorkerCliOptions) WithWorker(fn func(*v2.Context, client.Client) (worker.Worker, error)) *WorkerCliOptions {
	opts.worker = fn
	return opts
}

// NewWorkerCli initializes a cli for a(n) oms.billing.v1.Worker service
func NewWorkerCli(options ...*WorkerCliOptions) (*v2.App, error) {
	commands, err := newWorkerCommands(options...)
	if err != nil {
		return nil, fmt.Errorf("error initializing subcommands: %w", err)
	}
	return &v2.App{
		Name:     "worker",
		Commands: commands,
	}, nil
}

// NewWorkerCliCommand initializes a cli command for a oms.billing.v1.Worker service with subcommands for each query, signal, update, and workflow
func NewWorkerCliCommand(options ...*WorkerCliOptions) (*v2.Command, error) {
	subcommands, err := newWorkerCommands(options...)
	if err != nil {
		return nil, fmt.Errorf("error initializing subcommands: %w", err)
	}
	return &v2.Command{
		Name:        "worker",
		Subcommands: subcommands,
	}, nil
}

// newWorkerCommands initializes (sub)commands for a oms.billing.v1.Worker cli or command
func newWorkerCommands(options ...*WorkerCliOptions) ([]*v2.Command, error) {
	opts := &WorkerCliOptions{}
	if len(options) > 0 {
		opts = options[0]
	}
	if opts.clientForCommand == nil {
		opts.clientForCommand = func(*v2.Context) (client.Client, error) {
			return client.Dial(client.Options{})
		}
	}
	commands := []*v2.Command{
		{
			Name:                   "charge",
			Usage:                  "durably process an order from a customer",
			Category:               "WORKFLOWS",
			UseShortOptionHandling: true,
			Before:                 opts.before,
			After:                  opts.after,
			Flags: []v2.Flag{
				&v2.BoolFlag{
					Name:    "detach",
					Usage:   "run workflow in the background and print workflow and execution id",
					Aliases: []string{"d"},
				},
				&v2.StringFlag{
					Name:    "task-queue",
					Usage:   "task queue name",
					Aliases: []string{"t"},
					EnvVars: []string{"TEMPORAL_TASK_QUEUE_NAME", "TEMPORAL_TASK_QUEUE", "TASK_QUEUE_NAME", "TASK_QUEUE"},
					Value:   "billing-v1",
				},
				&v2.StringFlag{
					Name:    "input-file",
					Usage:   "path to json-formatted input file",
					Aliases: []string{"f"},
				},
				&v2.StringFlag{
					Name:     "customer-id",
					Usage:    "set the value of the operation's \"CustomerId\" parameter",
					Category: "INPUT",
				},
				&v2.StringFlag{
					Name:     "order-id",
					Usage:    "set the value of the operation's \"OrderId\" parameter",
					Category: "INPUT",
				},
				&v2.StringFlag{
					Name:     "fulfillment-id",
					Usage:    "set the value of the operation's \"FulfillmentId\" parameter",
					Category: "INPUT",
				},
				&v2.StringFlag{
					Name:     "reference",
					Usage:    "set the value of the operation's \"Reference\" parameter",
					Category: "INPUT",
				},
				&v2.StringSliceFlag{
					Name:     "items",
					Usage:    "set the value of the operation's \"Items\" parameter (json-encoded: {sku: <string>, description: <string>, quantity: <int32>})",
					Category: "INPUT",
				},
				&v2.StringFlag{
					Name:     "idempotency-key",
					Usage:    "set the value of the operation's \"IdempotencyKey\" parameter",
					Category: "INPUT",
				},
			},
			Action: func(cmd *v2.Context) error {
				tc, err := opts.clientForCommand(cmd)
				if err != nil {
					return fmt.Errorf("error initializing client for command: %w", err)
				}
				defer tc.Close()
				c := NewWorkerClient(tc)
				req, err := UnmarshalCliFlagsToChargeInput(cmd)
				if err != nil {
					return fmt.Errorf("error unmarshalling request: %w", err)
				}
				opts := client.StartWorkflowOptions{}
				if tq := cmd.String("task-queue"); tq != "" {
					opts.TaskQueue = tq
				}
				run, err := c.ChargeAsync(cmd.Context, req, NewChargeOptions().WithStartWorkflowOptions(opts))
				if err != nil {
					return fmt.Errorf("error starting %s workflow: %w", ChargeWorkflowName, err)
				}
				if cmd.Bool("detach") {
					fmt.Println("success")
					fmt.Printf("workflow id: %s\n", run.ID())
					fmt.Printf("run id: %s\n", run.RunID())
					return nil
				}
				if resp, err := run.Get(cmd.Context); err != nil {
					return err
				} else {
					b, err := protojson.Marshal(resp)
					if err != nil {
						return fmt.Errorf("error serializing response json: %w", err)
					}
					var out bytes.Buffer
					if err := json.Indent(&out, b, "", "  "); err != nil {
						return fmt.Errorf("error formatting json: %w", err)
					}
					fmt.Println(out.String())
					return nil
				}
			},
		},
	}
	if opts.worker != nil {
		commands = append(commands, []*v2.Command{
			{
				Name:                   "worker",
				Usage:                  "runs a oms.billing.v1.Worker worker process",
				UseShortOptionHandling: true,
				Before:                 opts.before,
				After:                  opts.after,
				Action: func(cmd *v2.Context) error {
					c, err := opts.clientForCommand(cmd)
					if err != nil {
						return fmt.Errorf("error initializing client for command: %w", err)
					}
					defer c.Close()
					w, err := opts.worker(cmd, c)
					if opts.worker != nil {
						if err != nil {
							return fmt.Errorf("error initializing worker: %w", err)
						}
					}
					if err := w.Start(); err != nil {
						return fmt.Errorf("error starting worker: %w", err)
					}
					defer w.Stop()
					<-cmd.Context.Done()
					return nil
				},
			},
		}...)
	}
	sort.Slice(commands, func(i, j int) bool {
		return commands[i].Name < commands[j].Name
	})
	return commands, nil
}

// UnmarshalCliFlagsToChargeInput unmarshals a ChargeInput from command line flags
func UnmarshalCliFlagsToChargeInput(cmd *v2.Context) (*ChargeInput, error) {
	var result ChargeInput
	var hasValues bool
	if cmd.IsSet("input-file") {
		inputFile, err := gohomedir.Expand(cmd.String("input-file"))
		if err != nil {
			inputFile = cmd.String("input-file")
		}
		b, err := os.ReadFile(inputFile)
		if err != nil {
			return nil, fmt.Errorf("error reading input-file: %w", err)
		}
		if err := protojson.Unmarshal(b, &result); err != nil {
			return nil, fmt.Errorf("error parsing input-file json: %w", err)
		}
		hasValues = true
	}
	if cmd.IsSet("customer-id") {
		hasValues = true
		result.CustomerId = cmd.String("customer-id")
	}
	if cmd.IsSet("order-id") {
		hasValues = true
		result.OrderId = cmd.String("order-id")
	}
	if cmd.IsSet("fulfillment-id") {
		hasValues = true
		result.FulfillmentId = cmd.String("fulfillment-id")
	}
	if cmd.IsSet("reference") {
		hasValues = true
		result.Reference = cmd.String("reference")
	}
	if cmd.IsSet("items") {
		hasValues = true
		var tmp ChargeInput
		if err := protojson.Unmarshal([]byte(fmt.Sprintf("{\"items\":%s}", cmd.String("items"))), &tmp); err != nil {
			return nil, fmt.Errorf("error unmarshalling \"items\" map flag: %w", err)
		}
		result.Items = tmp.Items
	}
	if cmd.IsSet("idempotency-key") {
		hasValues = true
		result.IdempotencyKey = cmd.String("idempotency-key")
	}
	if !hasValues {
		return nil, nil
	}
	return &result, nil
}

// WithWorkerSchemeTypes registers all Worker protobuf types with the given scheme
func WithWorkerSchemeTypes() scheme.Option {
	return func(s *scheme.Scheme) {
		s.RegisterType(File_oms_billing_v1_billing_proto.Messages().ByName("CheckFraudInput"))
		s.RegisterType(File_oms_billing_v1_billing_proto.Messages().ByName("CheckFraudResult"))
		s.RegisterType(File_oms_billing_v1_billing_proto.Messages().ByName("GenerateInvoiceInput"))
		s.RegisterType(File_oms_billing_v1_billing_proto.Messages().ByName("GenerateInvoiceResult"))
		s.RegisterType(File_oms_billing_v1_billing_proto.Messages().ByName("ProcessPaymentInput"))
		s.RegisterType(File_oms_billing_v1_billing_proto.Messages().ByName("ProcessPaymentResult"))
		s.RegisterType(File_oms_billing_v1_billing_proto.Messages().ByName("ChargeInput"))
		s.RegisterType(File_oms_billing_v1_billing_proto.Messages().ByName("ChargeResult"))
	}
}

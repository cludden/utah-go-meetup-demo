// @generated by protoc-gen-connect-es v1.5.0 with parameter "target=ts"
// @generated from file oms/order/v1/orders.proto (package oms.order.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import { CreateOrderInput, CreateOrderResult, CustomerActionInput, GetOrderInput, GetOrderResult, ListOrdersResult, ReserveItemsInput, ReserveItemsResult, UpdateOrderStatusInput } from "./orders_pb.js";
import { Empty, MethodIdempotency, MethodKind } from "@bufbuild/protobuf";

/**
 * @generated from service oms.order.v1.Api
 */
export const Api = {
  typeName: "oms.order.v1.Api",
  methods: {
    /**
     * submit a new order
     *
     * @generated from rpc oms.order.v1.Api.CreateOrder
     */
    createOrder: {
      name: "CreateOrder",
      I: CreateOrderInput,
      O: CreateOrderResult,
      kind: MethodKind.Unary,
    },
    /**
     * returns information about an existing order
     *
     * @generated from rpc oms.order.v1.Api.GetOrder
     */
    getOrder: {
      name: "GetOrder",
      I: GetOrderInput,
      O: GetOrderResult,
      kind: MethodKind.Unary,
      idempotency: MethodIdempotency.NoSideEffects,
    },
    /**
     * returns a list of existing orders
     *
     * @generated from rpc oms.order.v1.Api.ListOrders
     */
    listOrders: {
      name: "ListOrders",
      I: Empty,
      O: ListOrdersResult,
      kind: MethodKind.Unary,
      idempotency: MethodIdempotency.NoSideEffects,
    },
    /**
     * updates the status of an exsiting order
     *
     * @generated from rpc oms.order.v1.Api.UpdateOrderStatus
     */
    updateOrderStatus: {
      name: "UpdateOrderStatus",
      I: UpdateOrderStatusInput,
      O: Empty,
      kind: MethodKind.Unary,
    },
    /**
     * process a customer action
     *
     * @generated from rpc oms.order.v1.Api.CustomerAction
     */
    customerAction: {
      name: "CustomerAction",
      I: CustomerActionInput,
      O: Empty,
      kind: MethodKind.Unary,
    },
  }
} as const;

/**
 * @generated from service oms.order.v1.Worker
 */
export const Worker = {
  typeName: "oms.order.v1.Worker",
  methods: {
    /**
     * initialize a new order 
     *
     * @generated from rpc oms.order.v1.Worker.CreateOrder
     */
    createOrder: {
      name: "CreateOrder",
      I: CreateOrderInput,
      O: CreateOrderResult,
      kind: MethodKind.Unary,
    },
    /**
     * process a customer action
     *
     * @generated from rpc oms.order.v1.Worker.CustomerAction
     */
    customerAction: {
      name: "CustomerAction",
      I: CustomerActionInput,
      O: Empty,
      kind: MethodKind.Unary,
    },
    /**
     * returns information about the order
     *
     * @generated from rpc oms.order.v1.Worker.GetStatus
     */
    getStatus: {
      name: "GetStatus",
      I: Empty,
      O: GetOrderResult,
      kind: MethodKind.Unary,
    },
    /**
     * manage the lifecycle of an order
     *
     * @generated from rpc oms.order.v1.Worker.Order
     */
    order: {
      name: "Order",
      I: CreateOrderInput,
      O: CreateOrderResult,
      kind: MethodKind.Unary,
    },
    /**
     * reserves items to satisfy an order and returns a list of reservations for the items
     * Any unavailable items will be returned in a Reservation with Available set to false.
     * In a real system this would involve an inventory database of some kind.
     * For our purposes we just split orders arbitrarily.
     *
     * @generated from rpc oms.order.v1.Worker.ReserveItems
     */
    reserveItems: {
      name: "ReserveItems",
      I: ReserveItemsInput,
      O: ReserveItemsResult,
      kind: MethodKind.Unary,
    },
    /**
     * updates the order status in the database
     *
     * @generated from rpc oms.order.v1.Worker.UpdateOrderStatus
     */
    updateOrderStatus: {
      name: "UpdateOrderStatus",
      I: UpdateOrderStatusInput,
      O: Empty,
      kind: MethodKind.Unary,
    },
  }
} as const;

